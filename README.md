# 宿題の説明

## 性能（Time/ Utilization）

### best fit & free list bin(2の累乗でサイズ分け)
* Challenge #1
   * time: 14 => 35
   * utilization: 70 => 70
* Challenge #2
   * time: 17 => 11
   * utilization: 40 => 40
* Challenge #3
   * time: 162 => 32
   * utilization: 9 => 51
* Challenge #4
   * time: 51411 => 3389
   * utilization: 15 => 72
* Challenge #5
   * time: 45843 => 2235
   * utilization: 15 => 75

## 工夫したこと
1. first fit から　best fitへ変更
　　* 無限ループに陥らないためにbest_diffの初期値を工夫
       必要なメモリサイズと現在見ている空き領域のサイズとの差が最小であるときの差をbest_diffとし、これと各空き領域とサイズとの差とを比較した
      * このbest_diffの初期値が、メモリが不足している場合に追加する4096 - 16(metadataのサイズ) = 4080より小さい場合、常にbest_diffの初期値が最小となり、無限ループが生じる
      * そこで初期値を5000とした
   * 時間短縮のため、ある条件下でループを強制的に抜ける
      * best_diff=0となるものを見つけた時、それ以降の空き領域は見ずにループを抜けるようにした
      * best_diff=0となる空き領域はbest_fitであるので、それ以降のものを見る必要がない
      * これにより、free list bin内のすべての空き領域を確認する必要がなくなり時間の短縮につながる

2. free list binを複数作り、サイズによってグループ分け11個作り、2の累乗でサイズ分け
   * 時間の短縮のため,サイズを2の累乗で分けた
     * mallocするサイズが2の累乗であったため
     * また、mallocの要求サイズは小さいサイズの方が要求される確率は高いだろうと考え、小さいサイズのfree list binの範囲が細かくなるように累乗で分けた
     * これにより、一つのbinに入る空き領域の数が減り、効率的なfitの探索につながる
   * 2の1

## 考察
### best fit & free list bin(2の累乗でサイズ分け)
* challenge3~5では、best fit によりメモリ効率が上がった
    * challenge1, 2ではbest fit も first fitもメモリ効率は変わらなかった
      * このことから、challenge1, 2のように同じサイズのメモリを要求、解放する場合は、空きリストにある空き領域が同じサイズになるのでないかと考える
* free list binのサイズ分けにより、全てのchallengeで実行時間が短縮された
    * 同じサイズのメモリを要求、解放するchallenge1,2では短縮率が小さく、要求、解放するメモリサイズに幅がある3~5では短縮率が高かった
      * 要求、解放するメモリサイズが同じだと、同じサイズの空き領域ばかりできるので、とbinを分けても同じbinに空き領域が入ってしまい効果が小さいと考えられる
    